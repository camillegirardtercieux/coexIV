---
title: "Virtual experiment with two species"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    number_sections: true
  bookdown::pdf_book:
    toc: true
    toc_float: true
    number_sections: true
bibliography: "`r here::here('tools_latex', 'References.bib')`"
csl: "`r here::here('tools_latex', 'bib_style.csl')`"
header-includes:
  - \usepackage{booktabs}
  - \usepackage{longtable}
  - \usepackage{array}
  - \usepackage{multirow}
  - \usepackage{wrapfig}
  - \usepackage{float}
  - \usepackage{colortbl}
  - \usepackage{pdflscape}
  - \usepackage{tabu}
  - \usepackage{threeparttable}
  - \usepackage{threeparttablex}
  - \usepackage[normalem]{ulem}
  - \usepackage{makecell}
  - \usepackage{xcolor}
  - \usepackage{float}
  - \floatplacement{figure}{H}
  - \renewcommand{\thefigure}{S\thesection.\arabic{figure}}
  - \renewcommand{\thetable}{S\thesection.\arabic{table}}
always_allow_html: true
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, fig.pos='H')
```


Intraspecific variability (IV) is often seen as an intrinsic property of individuals, associated with genetics, which is often considered as unstructured in space and time. Here, we investigated whether observed IV can result from the species responses to the spatial variations of the environment. Our hypothesis was that the individuals can be clones, i.e. have no genetic differences between them, and still have different measured attributes because the environment in which they strive varies, as shown in the previous analysis of a clonal dataset. The response of an individual results from the integrated effects of the environmental conditions which the individual has encountered during its life (local environmental variation, also called microsite effect) and its genetic features. Moreover, the differences between individuals due to environmental variation does not imply a broader overlap of the species niches. Therefore, this type of IV has no direct effect on species coexistence.

Here, we designed and conducted a virtual experiment that aims at illustrating that IV, or “individual effects,” can result from variation in unobserved environmental variables [@clark_resolving_2007], therefore accounting for multidimensional species differences which cannot be observed on a few niche axes.


# Perfect knowledge model: generating response values.

To do so, we first considered a “perfect-knowledge” model that depicts the ecological response (e.g. growth) of individual clones for two different species as a function of a set of environmental variables. This model represents the perfect knowledge of the process as it occurs in the field and thus includes no residuals:

$Y_{ijt} = \beta_{0j} + \beta_{1j} * ln(X_{1ijt}) + \beta_{2j} * X_{2ijt} + \ldots + \beta_{Nj} * X_{Nijt}$
\hfill“Perfect knowledge model”

where $1 \leq i \leq 500$ are the individuals ; $1 \leq j \leq 2$ are the species ; $Y$ is a response variable, for instance growth ; $X_1$ to $XN$ are explanatory variables, for instance environmental variables, that can vary with time $t$ ; and the $\beta_{k,i}$ , $1 \leq k \leq N$ depict the species-specific responses to these environmental variables. As we consider clones, individuals of the same species respond the same way to environmental variables, and variation in $Y$ among individuals within species is due to differences in the environment where each individual thrives.
The first explanatory variable was natural log-transformed to represent a log-log relationship as would be the relationship between tree growth and light for example.

```{r seed, include=FALSE}
# set seed
set.seed(1234)
```

```{r BasicParameters, include=FALSE}

dim1 <- 500 #dimension of the grid
dim2 <- 500
nsp <- 2 #number of species
nind <- 500 #number of individuals per species
ntime <- 2 #number of observations per individual
nobs <- nsp*nind*ntime#number of observations

```

```{r SpeciesParameters, include=FALSE}
#10 parameters of species 1 and 2
#To modulate the overlap of the growth of both species, use the 9 random parameters: the closer to the second parameter, the more confused the statistical model will be. If many parameters are negative, it can even lead to a negative mean G ~ L relationship.
#In the current code, 5 variables have a positive effect on growth and 4 a negative effect.
  
param1 = c(0.25, 0.15, abs(runif(5, -0.05, 0.05)), -abs(runif(4, -0.05, 0.05)))
param2 = c(0.2, 0.10, abs(runif(5, -0.05, 0.05)), -abs(runif(4, -0.05, 0.05)))
  
par_sp <- cbind(param1, param2)

save(par_sp, file=here::here("outputs", "theoretical_model", "par_sp.RData"))
  
#Adding intrinsic IV
par_ind1 <- rbind(rnorm (nind, param1[1], abs(param1[1]/4)), rnorm (nind, param1[2], abs(param1[2]/4)), rnorm (nind, param1[3], abs(param1[3]/4)), rnorm (nind, param1[4], abs(param1[4]/4)),
                    rnorm (nind, param1[5], abs(param1[5]/4)), rnorm (nind, param1[6], abs(param1[6]/4)), rnorm (nind, param1[7], abs(param1[7]/4)), rnorm (nind, param1[8], abs(param1[8]/4)),
                    rnorm (nind, param1[9], abs(param1[9]/4)), rnorm (nind, param1[10], abs(param1[10]/4)), rnorm (nind, param1[11], abs(param1[11]/4)))
  par_ind2 <- rbind(rnorm (nind, param2[1], abs(param2[1]/4)), rnorm (nind, param2[2], abs(param2[2]/4)), rnorm (nind, param2[3], abs(param2[3]/4)), rnorm (nind, param2[4], abs(param2[4]/4)),
                    rnorm (nind, param2[5], abs(param2[5]/4)), rnorm (nind, param2[6], abs(param2[6]/4)), rnorm (nind, param2[7], abs(param2[7]/4)), rnorm (nind, param2[8], abs(param2[8]/4)),
                    rnorm (nind, param2[9], abs(param2[9]/4)), rnorm (nind, param2[10], abs(param2[10]/4)), rnorm (nind, param2[11], abs(param2[11]/4)))
  par_ind <- cbind(par_ind1, par_ind2)
```

We fixed the species parameters of the "Perfect knowledge model” as follows, using 10 environmental variables ($N$=10):

Parameters of species 1:  $\beta_0$ = `r param1[1]`, $\beta_1$ = `r param1[2]`, $\beta_2$ to $\beta_{6}$ were chosen randomly between -0.05 and 0.05 and $\beta_{7}$ to $\beta_{10}$ were chosen randomly between 0 and 0.05.

Parameters of species 2:  $\beta_0$ = `r param2[1]`, $\beta_1$ = `r param2[2]`, $\beta_2$ to $\beta_{10}$ were chosen the same way as for species 1.

The difference between the species is imposed by those parameters. Here, species 1 was more competitive on average thanks to its higher intercept ($\beta_0$) and responseto the first environmental variable ($\beta_1$).
The first environmental variable ($X_1$) has a higher weight in the computation of the response variable, as would be the most limiting factor for the response variable.

To account for intrinsic variability in our generated data, we added an IV in species parameters by sampling each individual parameter in a normal distribution centered on the species mean parameter and with a standard deviation of a quarter of the species mean parameter.

To represent the spatialised environment, we build a 2D matrix of dimension `r dim1` $\times$ `r dim2` for each environmental variable at a time $t_0$, by randomly generating them with spatial autocorrelation. We here considered that all environmental variables were independent.
Each variable was simulated by using the gstat R package [@pebesma_multivariable_2004 ; @graler_spatio-temporal_2016], enabling to create autocorrelated random fields. A spherical semivariogram model was used for each of the ten environmental variables, with a mean of 0 for each explanatory variable (beta = 0), a sill of 1 (psill = 1) for each and a range of 50 (range = 50).

```{r SpatialModels, include=FALSE}
#Matrixes of variables
  #Structure (coordinates)
  xy <- expand.grid(1:dim1, 1:dim2)
  names(xy) <- c("x","y")
  
  #Spatial models
  mods <- list()
  mods[[1]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[2]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[3]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[4]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[5]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[6]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[7]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[8]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[9]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50, nugget=0), nmax=20)
  mods[[10]] <- gstat::gstat(formula=z~1, locations=~x+y, dummy=T, beta=0, model=gstat::vgm(psill=1,model="Sph",range=50,nugget=0), nmax=20)
  
```

```{r EnvironmentalVariables, eval=FALSE, include=FALSE}
#this chunk takes time and can be skipped (files will be loaded)

#Z predictions
    Variables <- list()
    Vars_t0 <- data.frame(matrix(nrow = dim1*dim2, ncol = 12))
    Vars_t0[,1:2] <- xy
    for (k in 1:10) {
      Variables[[k]] <- predict(mods[[k]], newdata=xy, nsim=1)
      Vars_t0[,k+2] <- Variables[[k]][,3]
      sp::gridded(Variables[[k]]) = ~x+y
      print(sp::spplot(Variables[[k]]))
    }
    colnames(Vars_t0) <- c("x", "y", "Var1", "Var2", "Var3", "Var4","Var5", "Var6", "Var7", "Var8", "Var9", "Var10")
    
save(Variables, file=here::here("outputs", "theoretical_model", "Variables.RData"))
save(Vars_t0, file=here::here("outputs", "theoretical_model", "Vars_t0.RData"))
```

```{r LoadVariables, include=FALSE}
load(file=here::here("outputs", "theoretical_model", "Variables.RData"))
load(file=here::here("outputs", "theoretical_model", "Vars_t0.RData"))
```

We then considered that $Y$ had been measured at two times, $t_0$ and $t_1$, for each individual as it would be under periodic forest plot censuses for instance. A pair of coordinates within this spatialised environment was randomly assigned to each of the `r nind` individuals.
We considered that some of the environmental variables (light, temperature, humidity, nutrient availability for instance) had changed between $t_0$ and $t_1$ and others had not (slope, altitude for instance).
For the first environmental variable which had a stronger impact on $Y$ values and another randomly drawn environmental variable, we computed values at $t_1$ as $t_0 + \epsilon$, $\epsilon \sim \mathcal{N}(0, 0.1)$ (they randomly increase or decrease).
For two other environmental variables randomly drawn, $X_{t_1} = X_{t_0} + |\epsilon|, \epsilon \sim \mathcal{N}(0, 0.1)$ (they increase) and for two other environmental variables, $X_{t_1} = X_{t_0} - |\epsilon|, \epsilon \sim \mathcal{N}(0, 0.1)$ (they decrease).

This led to two repeated measurements of $Y$ for each individual of each species, i.e. `r nobs` values of $Y_{i,j,t}$, with $i=[1;2]$ ; $j=[1,50]$ ; $t=[t_0;t_1]$.

```{r SecondObservation}
# Second observation
#The variables have to vary in order to avoid identifiability problems + avoid a null residual variance
Vars_t1 <- Vars_t0
changing_variables <- sample(2:10, 5)
Vars_t1[,3] <- Vars_t1[,3] + abs(rnorm(1, mean=0, sd=0.1))
Vars_t1[,2+changing_variables[1]] <- Vars_t1[,2+changing_variables[1]] + abs(rnorm(1, mean=0, sd=0.1))
Vars_t1[,2+changing_variables[2]] <- Vars_t1[,2+changing_variables[2]] + abs(rnorm(1, mean=0, sd=0.1))
Vars_t1[,2+changing_variables[3]] <- Vars_t1[,2+changing_variables[3]] - abs(rnorm(1, mean=0, sd=0.1))
Vars_t1[,2+changing_variables[4]] <- Vars_t1[,2+changing_variables[4]] - abs(rnorm(1, mean=0, sd=0.1))
Vars_t1[,2+changing_variables[5]] <- Vars_t1[,2+changing_variables[5]] + rnorm(1, mean=0, sd=0.1)

```

```{r IndividualCoordinates}
 #Sample the coordinates of the individuals in the matrices of variables for each species
Coord <- data.frame(matrix(nrow=2, ncol=nind*nsp))
for (k in 1:ncol(Coord)) {
  Coord[,k] <- sample(1:dim1, 2, rep = TRUE)
}
#Making sure there is no duplicate in the coordinates couples (one individual only on a couple of coordinates)
while (any(duplicated.array(Coord, MARGIN=2))==TRUE) {
  Coord[,which(duplicated.array(Coord, MARGIN=2)==TRUE)] <- sample(1:dim1, 2, rep = TRUE)
}

Coord1_sp1 = Coord[1, 1:nind]
Coord2_sp1 = Coord[2, 1:nind]
Coord1_sp2 = Coord[1, (nind+1):(2*nind)]
Coord2_sp2 = Coord[2, (nind+1):(2*nind)]

#Species 1

#explanatory variables for species 1
VarExp_sp1_t0 <- data.frame(matrix(nrow = nind, ncol = 10))

for (ind in 1:nind) {
  VarExp_sp1_t0[ind,] <- Vars_t0[Vars_t0$x==Coord1_sp1[,ind]&Vars_t0$y==Coord2_sp1[,ind],][,3:12]
}

VarExp_sp1_t1 <- data.frame(matrix(nrow = nind, ncol = 10))
for (ind in 1:nind) {
  VarExp_sp1_t1[ind,] <- Vars_t1[Vars_t1$x==Coord1_sp1[,ind]&Vars_t1$y==Coord2_sp1[,ind],][,3:12]
}

#Species 2
VarExp_sp2_t0 <- data.frame(matrix(nrow = nind, ncol = 10))

for (ind in 1:nind) {
  VarExp_sp2_t0[ind,] <- Vars_t0[Vars_t0$x==Coord1_sp2[,ind]&Vars_t0$y==Coord2_sp2[,ind],][,3:12]
}

VarExp_sp2_t1 <- data.frame(matrix(nrow = nind, ncol = 10))

for (ind in 1:nind) {
  VarExp_sp2_t1[ind,] <- Vars_t1[Vars_t1$x==Coord1_sp2[,ind]&Vars_t1$y==Coord2_sp2[,ind],][,3:12]
}

# Large explanatory variable matrix for all observations (including 1 for intercept)
VarExp <- as.matrix(rbind(VarExp_sp1_t0, VarExp_sp1_t1, VarExp_sp2_t0, VarExp_sp2_t1))
X <- cbind(rep(1, nobs), VarExp)

```

```{r Growth, include=FALSE}
# Growth of each individual

Growth <- data.frame(Species=rep(c(1,2), each=nind*ntime),
                         Ind=c(rep(c(1:nind), ntime), rep((nind+1):(nind*2), ntime)),
                         Time=rep(c(1,2,1,2),each=nind),
                         Growth=double(nobs),
                         Growth_sp=double(nobs))

Xloglight <- X

#constant to avoid NaNs while log-transforming
const_log <- 4
Xloglight[,2] <- log(Xloglight[,2]+const_log)
    
# Process model: log(G) = beta1+beta2*log(Light)+...+beta10*X10
Growth$Growth <- exp(rowSums(Xloglight * t(par_ind[,Growth$Ind])))
 #Without intrinsic variability
Growth$Growth_sp <- exp(rowSums(Xloglight * t(par_sp[,Growth$Species])))
    
Growth$Species <- as.factor(Growth$Species)
Growth$Ind <- as.factor(Growth$Ind)

Growth$logLight <- Xloglight[,2] 

Growth$logGrowth <- log(Growth$Growth)
Growth$logGrowth_sp <- log(Growth$Growth_sp)
    
```

```{r GrowthPlots, message=FALSE, warning=FALSE, include=FALSE}
# Plot the data

Growth$Light <- exp(Growth$logLight)-const_log

scatterplot1 <- ggplot2::ggplot(Growth, ggplot2::aes(x=Light, y= Growth_sp))+
  ggplot2::geom_point()+
  ggplot2::labs(x= "X1",
                y = "Y",
                title = "Y versus X1 \n without intrinsic IV")
ggplot2::ggsave(filename = "Plot_Light_Growth.png", plot = scatterplot1, path = here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)


scatterplot2 <- ggplot2::ggplot(Growth, ggplot2::aes(x=logLight, y= logGrowth_sp))+
  ggplot2::geom_point()+
  ggplot2::labs(x= "log(X1+constant)",
                y = "log(Y)",
                title = "log-transformed Y versus X1 \n without intrinsic IV")
ggplot2::ggsave(filename = "Plot_logLight_logGrowth.png", plot = scatterplot2, path = here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

scatterplot3 <- ggplot2::ggplot(Growth, ggplot2::aes(x=Light, y= Growth))+
  ggplot2::geom_point()+
  ggplot2::labs(x= "X1",
                y = "Y",
                title = "Y versus X1 \n with intrinsic IV")
ggplot2::ggsave(filename = "Plot_Light_Growth_IV.png", plot = scatterplot3, path = here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

scatterplot4 <- ggplot2::ggplot(Growth, ggplot2::aes(x=logLight, y= logGrowth))+
  ggplot2::geom_point()+
  ggplot2::labs(x= "log(X1+constant)",
                y = "log(Y)",
                title = "log-transformed Y versus X1 \n with intrinsic IV")
ggplot2::ggsave(filename = "Plot_logLight_logGrowth_IV.png", plot = scatterplot4, path= here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

histo1 <- ggplot2::ggplot(Growth, ggplot2::aes(x=Growth_sp))+
  ggplot2::geom_histogram(color="black", fill="white", bins=30)+
  ggplot2::labs(x= "Y",
                y = "Frequency",
                title = "Histogram of Y \n without intrinsic IV")
ggplot2::ggsave(filename = "Histogram_Growth.png", plot = histo1, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

histo2 <- ggplot2::ggplot(Growth, ggplot2::aes(x=logGrowth_sp))+
  ggplot2::geom_histogram(color="black", fill="white", bins=30)+
  ggplot2::labs(x= "log(Y)",
                y = "Frequency",
                title = "Histogram of log-transformed Y \n without intrinsic IV")
ggplot2::ggsave(filename = "Histogram_logGrowth.png", plot = histo2, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

histo3 <- ggplot2::ggplot(Growth, ggplot2::aes(x=Growth))+
  ggplot2::geom_histogram(color="black", fill="white", bins=30)+
  ggplot2::labs(x= "Y",
                y = "Frequency",
                title = "Histogram of Y \n with intrinsic IV")
ggplot2::ggsave(filename = "Histogram_Growth_IV.png", plot = histo3, path = here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

histo4 <- ggplot2::ggplot(Growth, ggplot2::aes(x=logGrowth))+
  ggplot2::geom_histogram(color="black", fill="white", bins=30)+
  ggplot2::labs(x= "log(Y)",
                y = "Frequency",
                title = "Histogram of log-transformed Y \n with intrinsic IV")
ggplot2::ggsave(filename = "Histogram_logGrowth_IV.png", plot = histo4, path = here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

#we represent the growth of each individual at time t0
Growth_illustration <- Growth[which(Growth$Time==1),]
Growth_illustration$X <- t(Coord)[,1]
Growth_illustration$Y <- t(Coord)[,2]
#Reduce the number of individuals represented to make the figure more clear
Growth_illustration <- Growth_illustration[sample(1:nrow(Growth_illustration), 200),]

A <- ggplot2::ggplot(Vars_t0, ggplot2::aes(x, y)) +
  ggplot2::geom_point(ggplot2::aes(color = Var1), alpha = 0.1, size = 0.1) +
  ggplot2::scale_color_viridis_c(
    "Environmental variable X1",
    guide = ggplot2::guide_colourbar(
      title.position = "top",
      label.position="bottom"),
    limits = c(-4.5, 4.5),
    breaks = c(-4, -2, 0, 2, 4)) +
  ggnewscale::new_scale_color() +
  ggplot2::geom_point(data=Growth_illustration,
                      ggplot2::aes(
                        x = X,
                        y = Y,
                        color = Growth_sp,
                        shape=as.factor(Species)),
                      size=2.5) +
  ggplot2::scale_color_viridis_c("Response Y", option = "plasma")+
  ggplot2::guides(
    shape=ggplot2::guide_legend(
      title = "Species",
      title.position = "top",
      label.position = "bottom"),
    color=ggplot2::guide_colourbar(
      title.position = "top",
      label.position="bottom"))+
  ggplot2::scale_y_continuous(expand = c(0, 0))+
  ggplot2::scale_x_continuous(expand = c(0, 0))+
  ggplot2::coord_fixed(ratio = 1)+
  ggplot2::theme_bw() +
  ggplot2::theme(plot.background = ggplot2::element_blank(),
            panel.grid.major = ggplot2::element_blank(),
            panel.grid.minor = ggplot2::element_blank(),
            panel.border = ggplot2::element_blank(),
            legend.title = ggplot2::element_text(size = 12),
            legend.text = ggplot2::element_text(size = 10),
            text = ggplot2::element_text(size=12),
            legend.position="bottom")+
  ggplot2::xlab("Longitude")+
  ggplot2::ylab("Latitude")
    
ggplot2::ggsave(filename = "Map_growth.png", plot=A, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

```

```{r HistogramsGrowth, fig.cap="Histogram of raw and log-transformed Y with and without intrinsic IV"}

g <- ggpubr::ggarrange(histo1, histo2, histo3, histo4, ncol=2, nrow=2, labels=c("a", "b", "c", "d"))
ggplot2::ggsave(filename="arranged_histograms_theoretical.png",path=here::here("outputs", "theoretical_model", "figures"),plot=g, device = "png", width = 7, height = 5, dpi = 300)
knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "arranged_histograms_theoretical.png"))

```

```{r PlotsXY, fig.cap="Raw and log-transformed $Y$ versus $X_1$ plots with and without intrinsic IV"}

g <- ggpubr::ggarrange(scatterplot1, scatterplot2, scatterplot3, scatterplot4, ncol=2, nrow=2, labels=c("a", "b", "c", "d"))
ggplot2::ggsave(filename="arranged_plots_theoretical.png",path=here::here("outputs", "theoretical_model", "figures"),plot=g, device = "png", width = 7, height = 5, dpi = 300)
knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "arranged_plots_theoretical.png"))
```

Figure \@ref(fig:HistogramsGrowth) shows the distribution of the data and Figure \@ref(fig:PlotsXY) shows the relationship between the response $Y$ and the environmental variable $X_1$.

```{r MapGrowth, fig.cap="Virtual landscape representing $X_1$ and the individual with their respective $Y$ value."}
knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Map_growth.png"))
```

Figure \@ref(fig:MapGrowth) shows that microsite effects, which are the effects of the local multidimensional environment on the response variable, can result in local reversals of the competitive hierarchy between species. Indeed, the local outcome of competition can be opposite to the mean hierarchy: at one point of the space-time, an individual of Species 1 can overcome an individual of Species 2, whilst Species 1 is, on average, the fittest of the two species. Consequently, niche multidimensionality and variation of the environment in space allow the coexistence of Species 1 and Species 2.


# Partial knowledge model: interpreting the response values with only one explanatory variable.

These two virtual datasets (with and without intrinsic variability) were then analysed with a “Partial knowledge model,” which represents the model derived by ecologists when using datasets derived from an incomplete characterisation of the environment: only a few variables (here only one, $X_1$) are actually measured and taken into account.


$\ln(Y_{ijt}) = [\beta'_{0j} + b_{0i}] + \beta'_{1j} \ln(X_{1ijt}) + \varepsilon_{ijt}$
\hfill“Partial knowledge model”

Priors:

$\varepsilon_{ijt} \sim \mathcal{N}(0,V_j)$, $j = [1, 2]$, iid

$\beta'_{kj}\sim \mathcal{N}_2(0, 1)$, $k = [0, 1]$, $j = [1, 2]$, iid

$b_{0i} \sim \mathcal{N}(0, V_{bj})$, $i = [1, 500]$, $j = [1, 2]$, iid

Second level priors:

$V_j \sim \mathcal{IG}(10^-3, 10^-3)$, $j = [1, 2]$, iid

$V_{bj} \sim \mathcal{IG}_2(10^-3, 10^-3)$, $j = [1, 2]$, iid

This model includes a random individual effect on the intercept ($b_{0i}$) to account for  the variability among individuals within species.
We ran this model twice, with the datasets generated with and without intrinsic IV. These models were fitted in a hierarchical Bayesian framework using the brms package [@burkner_brms_2017 ; @burkner_advanced_2018 ] with 10,0000 iterations, a warming period of 50,000 iterations and a thinning of 50. We obtained 1,000 estimates per parameter.

```{r brmsModels, eval=FALSE, include=FALSE}
#Statistical model with only one variable X

Data_brms_sp_1 <- data.frame(Y = Growth[which(Growth$Species==1),]$logGrowth_sp, X1 = Growth[which(Growth$Species==1),]$logLight, tree = Growth[which(Growth$Species==1),]$Ind)
  #dplyr::mutate(Y=scale(Y), X1=scale(X1))

Data_brms_sp_2 <- data.frame(Y = Growth[which(Growth$Species==2),]$logGrowth_sp, X1 = Growth[which(Growth$Species==2),]$logLight, tree = Growth[which(Growth$Species==2),]$Ind)
  #dplyr::mutate(Y=scale(Y), X1=scale(X1))

Data_brms_sp_1_IV <- data.frame(Y = Growth[which(Growth$Species==1),]$logGrowth, X1 = Growth[which(Growth$Species==1),]$logLight, tree = Growth[which(Growth$Species==1),]$Ind)
  #dplyr::mutate(Y=scale(Y), X1=scale(X1))

Data_brms_sp_2_IV <- data.frame(Y = Growth[which(Growth$Species==2),]$logGrowth, X1 = Growth[which(Growth$Species==2),]$logLight, tree = Growth[which(Growth$Species==2),]$Ind)
  #dplyr::mutate(Y=scale(Y), X1=scale(X1))


options("m.cores"=2)
    
### Priors
    
prior_brms <- c(brms::prior(normal(0, 1), class = "Intercept"),
                brms::prior(normal(0, 1), class = "b"),
                brms::prior(inv_gamma(10^-3, 10^-3), class = "sd"))
    
### Models
    
brms_mod_sp_1 <- brms::brm(formula = Y ~  1 + X1 + (1|tree), 
                      data = Data_brms_sp_1,
                      prior= prior_brms,
                      iter = 100000 , warmup = 50000, thin = 50,
                      chains = 2, cores=2)

save(brms_mod_sp_1, file = here::here("outputs", "theoretical_model", "brms_mod_sp_1.RData"))

brms_mod_sp_2 <- brms::brm(formula = Y ~  1 + X1 + (1|tree), 
                      data = Data_brms_sp_2,
                      prior= prior_brms,
                      iter = 100000 , warmup = 50000, thin = 50,
                      chains = 2, cores=2)

save(brms_mod_sp_2, file = here::here("outputs", "theoretical_model", "brms_mod_sp_2.RData"))

brms_mod_sp_1_IV <- brms::brm(formula = Y ~  1 + X1 + (1|tree), 
                      data = Data_brms_sp_1_IV,
                      prior= prior_brms,
                      iter = 100000 , warmup = 50000, thin = 50,
                      chains = 2, cores=2)

save(brms_mod_sp_1_IV, file = here::here("outputs", "theoretical_model", "brms_mod_sp_1_IV.RData"))

brms_mod_sp_2_IV <- brms::brm(formula = Y ~  1 + X1 + (1|tree), 
                      data = Data_brms_sp_2_IV,
                      prior= prior_brms,
                      iter = 100000 , warmup = 50000, thin = 50,
                      chains = 2, cores=2)

save(brms_mod_sp_2_IV, file = here::here("outputs", "theoretical_model", "brms_mod_sp_2_IV.RData"))

```

```{r LoadModels, include=FALSE}
load(here::here("outputs", "theoretical_model", "brms_mod_sp_1.RData"))
load(here::here("outputs", "theoretical_model", "brms_mod_sp_2.RData"))
load(here::here("outputs", "theoretical_model", "brms_mod_sp_1_IV.RData"))
load(here::here("outputs", "theoretical_model", "brms_mod_sp_2_IV.RData"))

MCMC_brms_sp_1 <- brms::as.mcmc(brms_mod_sp_1)
MCMC_brms_sp_2 <- brms::as.mcmc(brms_mod_sp_2)
MCMC_brms_sp_1_IV <- brms::as.mcmc(brms_mod_sp_1_IV)
MCMC_brms_sp_2_IV <- brms::as.mcmc(brms_mod_sp_2_IV)

```

We visualised the convergence and the results of the models thanks to trace and density plots.

```{r TraceSp1, fig.cap="Trace of the posterior of the model for Species 1 without intrinsic IV", message=FALSE, warning=FALSE}
g <- brms::mcmc_plot(brms_mod_sp_1, type="trace")

ggplot2::ggsave(filename = "Trace_model_Sp1.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Trace_model_Sp1.png"))
```

```{r DensSp1, fig.cap="Density of the posterior of the model for Species 1 without intrinsic IV"}
g <- brms::mcmc_plot(brms_mod_sp_1, type="dens")

ggplot2::ggsave(filename = "Density_model_Sp1.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Density_model_Sp1.png"))
```

```{r TraceSp2, fig.cap="Trace of the posterior of the model for Species 2 without intrinsic IV", message=FALSE, warning=FALSE}
g <- brms::mcmc_plot(brms_mod_sp_2, type="trace")

ggplot2::ggsave(filename = "Trace_model_Sp2.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Trace_model_Sp2.png"))
```

```{r DensSp2, fig.cap="Density of the posterior of the model for Species 2 without intrinsic IV"}
g <- brms::mcmc_plot(brms_mod_sp_2, type="dens")

ggplot2::ggsave(filename = "Dens_model_Sp2.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Dens_model_Sp2.png"))
```

```{r TraceIVSp1, fig.cap="Trace of the posterior of the model for Species 1 with intrinsic IV", message=FALSE, warning=FALSE}
g <- brms::mcmc_plot(brms_mod_sp_1_IV, type="trace")

ggplot2::ggsave(filename = "Trace_model_IV_Sp1.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Trace_model_IV_Sp1.png"))
```

```{r DensIVSp1, fig.cap="Density of the posterior of the model for Species 1 with intrinsic IV"}
g <- brms::mcmc_plot(brms_mod_sp_1_IV, type="dens")

ggplot2::ggsave(filename = "Dens_model_IV_Sp1.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Dens_model_IV_Sp1.png"))
```

```{r TraceIVSp2, fig.cap="Trace of the posteriors of the model for Species 2 with intrinsic IV", message=FALSE, warning=FALSE}
g <- brms::mcmc_plot(brms_mod_sp_2_IV, type="trace")

ggplot2::ggsave(filename = "Trace_model_IV_Sp2.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Trace_model_IV_Sp2.png"))
```

```{r DensIVSp2, fig.cap="Density of the posteriors of the model for Species 2 with intrinsic IV"}
g <- brms::mcmc_plot(brms_mod_sp_2_IV, type="dens")

ggplot2::ggsave(filename = "Dens_model_IV_Sp2.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Dens_model_IV_Sp2.png"))
```

```{r brmsSummary}

load(here::here("outputs", "theoretical_model", "brms_mod_sp_1.RData"))
load(here::here("outputs", "theoretical_model", "brms_mod_sp_2.RData"))
load(here::here("outputs", "theoretical_model", "brms_mod_sp_1_IV.RData"))
load(here::here("outputs", "theoretical_model", "brms_mod_sp_2_IV.RData"))

Sum_sp1 <- summary(brms_mod_sp_1)
Sum_sp2 <- summary(brms_mod_sp_2)
Sum_sp1_IV <- summary(brms_mod_sp_1_IV)
Sum_sp2_IV <- summary(brms_mod_sp_2_IV)

kableExtra::kbl(
  data.frame(
    rep(c("Estimate", "Estimation error"), 4),
    c(format(as.numeric(Sum_sp1$fixed[1,1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1$fixed[1,2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2$fixed[1,1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2$fixed[1,2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1_IV$fixed[1,1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1_IV$fixed[1,2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2_IV$fixed[1,1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2_IV$fixed[1,2]), digits = 2, scientific = T)),
    c(format(as.numeric(Sum_sp1$fixed[2,1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1$fixed[2,2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2$fixed[2,1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2$fixed[2,2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1_IV$fixed[2,1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1_IV$fixed[2,2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2_IV$fixed[2,1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2_IV$fixed[2,2]), digits = 2, scientific = T)),
    c(format(as.numeric(Sum_sp1$random$tree[1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1$random$tree[2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2$random$tree[1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2$random$tree[2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1_IV$random$tree[1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1_IV$random$tree[2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2_IV$random$tree[1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2_IV$random$tree[2]), digits = 2, scientific = T)),
    c(format(as.numeric(Sum_sp1$spec_pars[1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1$spec_pars[2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2$spec_pars[1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2$spec_pars[2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1_IV$spec_pars[1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp1_IV$spec_pars[2]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2_IV$spec_pars[1]), digits = 2, scientific = T),
      format(as.numeric(Sum_sp2_IV$spec_pars[2]), digits = 2, scientific = T))
    ),
  booktabs = T,
  col.names = c(" ", "$\\beta_0$", "$\\beta_1$", "$V_b$", "$V$"),
  escape = F,
  caption = "Mean posteriors and their estimation error"
  ) %>%
  kableExtra::pack_rows("Species 1 (no random IV)", start_row = 1, end_row = 2) %>% 
  kableExtra::pack_rows("Species 2 (no random IV)", start_row = 3, end_row = 4)%>%
  kableExtra::pack_rows("Species 1 (with random IV)", start_row = 5, end_row = 6) %>% 
  kableExtra::pack_rows("Species 2 (with random IV)", start_row = 7, end_row = 8)%>%
  kableExtra::kable_styling(latex_options = c("striped", "hold_position"), full_width = F)
```

We inferred a high IV even in the absence of intrinsic IV (Table \@ref(tab:brmsSummary)). Therefore, observed IV does not necessarily reveal intrinsic (mainly genetic) IV, but can also reveal hidden dimensions of the environment.
We used the model parameters to plot the relationship between $Y$ and $X_1$ accounting for intraspecific variability.

```{r GrowthNoIntrinsicIV}

 #Create a sequence of 100 values of X
    npred <- 100
    logLight_seq <- seq(min(Growth$logLight), max(Growth$logLight), length.out=npred)

    Sd_b_sp1 <- mean(c(MCMC_brms_sp_1[[1]][,3], MCMC_brms_sp_1[[2]][,3]))
    Sd_b_sp1_IV <- mean(c(MCMC_brms_sp_1_IV[[1]][,3], MCMC_brms_sp_1_IV[[2]][,3]))
    Sd_b_sp2 <- mean(c(MCMC_brms_sp_2[[1]][,3], MCMC_brms_sp_2[[2]][,3]))
    Sd_b_sp2_IV <- mean(c(MCMC_brms_sp_2_IV[[1]][,3], MCMC_brms_sp_2_IV[[2]][,3]))
    
    #Without intrinsic variation#
    Param_sp1 <- data.frame(beta1_sp1=numeric(2000), beta2_sp1=numeric(2000), ind=numeric(2000))
    Param_sp1[,1] <- c(MCMC_brms_sp_1[[1]][,1], MCMC_brms_sp_1[[2]][,1])
    Param_sp1[,2] <- c(MCMC_brms_sp_1[[1]][,2], MCMC_brms_sp_1[[2]][,2])
    Param_sp1[,3] <- rnorm(2000, 0, Sd_b_sp1)
    Log_growth_pred_sp1 <- matrix(nrow=2000, ncol=npred)
    for (n in 1:npred) {
      Log_growth_pred_sp1[,n] <- Param_sp1$beta1_sp1 + Param_sp1$beta2_sp1*logLight_seq[n] + Param_sp1$ind
    }
    
    Param_sp2 <- data.frame(beta1_sp2=numeric(2000), beta2_sp2=numeric(2000), ind=numeric(2000))
    Param_sp2[,1] <- c(MCMC_brms_sp_2[[1]][,1], MCMC_brms_sp_2[[2]][,1])
    Param_sp2[,2] <- c(MCMC_brms_sp_2[[1]][,2], MCMC_brms_sp_2[[2]][,2])
    Param_sp2[,3] <- rnorm(2000, 0, Sd_b_sp2)
    Log_growth_pred_sp2 <- matrix(nrow=2000, ncol=npred)
    for (n in 1:npred) {
      Log_growth_pred_sp2[,n] <- Param_sp2$beta1_sp2 + Param_sp2$beta2_sp2*logLight_seq[n] + Param_sp2$ind
    }
    
    Mean_sp1 <- apply(Log_growth_pred_sp1,2,mean)
    Quant_sp1 <- apply(Log_growth_pred_sp1,2,quantile,c(0.025,0.975))
    Mean_sp2 <- apply(Log_growth_pred_sp2,2,mean)
    Quant_sp2 <- apply(Log_growth_pred_sp2,2,quantile,c(0.025,0.975))
    
    Marg_sp1 <- data.frame(logLight_seq, Mean_sp = Mean_sp1, Q025_sp = Quant_sp1[1,], Q975_sp = Quant_sp1[2,])
    Marg_sp2 <- data.frame(logLight_seq, Mean_sp = Mean_sp2, Q025_sp = Quant_sp2[1,], Q975_sp = Quant_sp2[2,])
    
    Marg_sp <- rbind(Marg_sp1, Marg_sp2)
    names(Marg_sp) <- c("logLight", "logGrowth_sp", "logQ025_sp", "logQ975_sp")
    Marg_sp$Species<- rep(c(1,2), each = npred)
    Marg_sp$Species <- as.factor(Marg_sp$Species)
    
    #Use exponential to draw a logarithmical curve
    Marg_sp$Light <- exp(Marg_sp$logLight) - const_log
    Marg_sp$Growth_sp <- exp(Marg_sp$logGrowth_sp)
    Marg_sp$Q025_sp <- exp(Marg_sp$logQ025_sp)
    Marg_sp$Q975_sp <- exp(Marg_sp$logQ975_sp)
    
    Growth$Light <- exp(Growth$logLight) - const_log
    
B <- ggplot2::ggplot(data=Growth[which(Growth$Time==1),], ggplot2::aes(Light, Growth_sp)) +
  ggplot2::geom_point(ggplot2::aes(colour=Species)) +
  ggplot2::geom_line(data=Marg_sp, size=1, ggplot2::aes(colour=Species)) +
  ggplot2::geom_ribbon(data=Marg_sp, alpha=0.2, ggplot2::aes(Light, ymin=Q025_sp, ymax=Q975_sp, colour=Species, fill=Species))+
  ggplot2::coord_fixed(ratio=3)+
  ggplot2::xlab("Environmental variable X1")+
  ggplot2::ylab("Response Y")+
  ggplot2::scale_color_manual(values=c("midnightblue", "orange")) +
  ggplot2::scale_fill_manual(values=c("midnightblue", "orange")) +
  ggplot2::guides(fill=ggplot2::guide_legend(title.position = "top",
                           label.position = "bottom"))+
  ggplot2::theme(
    legend.position = "bottom",
     legend.title = ggplot2::element_text(size = 12),
     legend.text = ggplot2::element_text(size = 10),
     text = ggplot2::element_text(size=12))

ggplot2::ggsave(filename = "Partial_knowledge_model.png", plot=B, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)

```

```{r GrowthIntrinsicIV}
#With intrinsic variation#
    
    #Growth for species 1
    Param_sp1_IV <- data.frame(beta1_sp1_IV=numeric(2000), beta2_sp1_IV=numeric(2000), ind=numeric(2000))
    Param_sp1_IV[,1] <- c(MCMC_brms_sp_1_IV[[1]][,1], MCMC_brms_sp_1_IV[[2]][,1])
    Param_sp1_IV[,2] <- c(MCMC_brms_sp_1_IV[[1]][,2], MCMC_brms_sp_1_IV[[2]][,2])
    Param_sp1_IV[,3] <- rnorm(2000, 0, Sd_b_sp1_IV)
    
    Log_growth_pred_sp1_IV <- matrix(nrow=2000, ncol=npred)
    
    for (n in 1:npred) {
      Log_growth_pred_sp1_IV[,n] <- Param_sp1_IV$beta1_sp1_IV + Param_sp1_IV$beta2_sp1_IV*logLight_seq[n] + Param_sp1_IV$ind
    }
    
    #Growth for species 2
    Param_sp2_IV <- data.frame(beta1_sp2_IV=numeric(2000), beta2_sp2_IV=numeric(2000), ind=numeric(2000))
    Param_sp2_IV[,1] <- c(MCMC_brms_sp_2_IV[[1]][,1], MCMC_brms_sp_2_IV[[2]][,1])
    Param_sp2_IV[,2] <- c(MCMC_brms_sp_2_IV[[1]][,2], MCMC_brms_sp_2_IV[[2]][,2])
    Param_sp2_IV[,3] <- rnorm(2000, 0, Sd_b_sp2_IV)
    
    Log_growth_pred_sp2_IV <- matrix(nrow=2000, ncol=npred)
    
    for (n in 1:npred) {
      Log_growth_pred_sp2_IV[,n] <- Param_sp2_IV$beta1_sp2_IV + Param_sp2_IV$beta2_sp2_IV*logLight_seq[n] + Param_sp2_IV$ind
    }
    
    #Mean and quantiles
    Mean_sp1_IV <- apply(Log_growth_pred_sp1_IV,2,mean)
    Quant_sp1_IV <- apply(Log_growth_pred_sp1_IV,2,quantile,c(0.025,0.975))
    Mean_sp2_IV <- apply(Log_growth_pred_sp2_IV,2,mean)
    Quant_sp2_IV <- apply(Log_growth_pred_sp2_IV,2,quantile,c(0.025,0.975))
    
    
    Marg_sp1_both <- data.frame(logLight_seq, Mean = Mean_sp1, Q025 = Quant_sp1[1,], Q975 = Quant_sp1[2,], Mean_IV = Mean_sp1_IV, Q025_IV = Quant_sp1_IV[1,], Q975_IV = Quant_sp1_IV[2,])
    Marg_sp2_both <- data.frame(logLight_seq, Mean = Mean_sp2, Q025 = Quant_sp2[1,], Q975 = Quant_sp2[2,], Mean_IV = Mean_sp2_IV, Q025_IV = Quant_sp2_IV[1,], Q975_IV = Quant_sp2_IV[2,])
    
    Marg <- rbind(Marg_sp1_both, Marg_sp2_both)
    names(Marg) <- c("logLight", "logGrowth", "logQ025", "logQ975", "logGrowthIV", "logQ025IV", "logQ975IV")
    Marg$Species<- rep(c(1,2), each = npred)
    Marg$Species <- as.factor(Marg$Species)
    
    #Use exponential to draw a logarithmical curve
    Marg$Light <- exp(Marg$logLight)-const_log
    Marg$Growth <- exp(Marg$logGrowth)
    Marg$Q025 <- exp(Marg$logQ025)
    Marg$Q975 <- exp(Marg$logQ975)
    Marg$Growth_IV <- exp(Marg$logGrowthIV)
    Marg$Q025_IV <- exp(Marg$logQ025IV)
    Marg$Q975_IV <- exp(Marg$logQ975IV)
    
    Growth$Light <- exp(Growth$logLight) - const_log
    
g <- ggplot2::ggplot(data=Growth[which(Growth$Time==1),], ggplot2::aes(Light, Growth))+
  ggplot2::geom_point(ggplot2::aes(colour=Species))+
  ggplot2::geom_line(data=Marg, size=1, ggplot2::aes(colour=Species), linetype=1)+
  ggplot2::geom_line(data=Marg, size=1, ggplot2::aes(x=Light, y=Growth_IV, colour=Species), linetype=2)+
  ggplot2::geom_ribbon(data=Marg, alpha=0.2, ggplot2::aes(Light, ymin=Q025, ymax=Q975, colour=Species, fill=Species), linetype=1)+
  ggplot2::geom_ribbon(data=Marg, alpha=0.2, ggplot2::aes(Light, ymin=Q025_IV, ymax=Q975_IV, colour=Species, fill=Species), linetype=2)+
  ggplot2::coord_fixed(ratio=3)+
  ggplot2::xlab("Environmental variable X1")+
  ggplot2::ylab("Response Y")+
  ggplot2::scale_color_manual(values=c("midnightblue", "orange"))+
  ggplot2::scale_fill_manual(values=c("midnightblue", "orange"))+
  ggplot2::guides(fill=ggplot2::guide_legend(title.position = "top",
                           label.position = "bottom"))+
  ggplot2::theme(
    legend.position = "bottom",
     legend.title = ggplot2::element_text(size = 12),
     legend.text = ggplot2::element_text(size = 10),
     text = ggplot2::element_text(size=12))

ggplot2::ggsave(filename = "Partial_knowledge_model_genetic_var.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)
```


```{r PlotIntrinsicIV, fig.cap="Plot of the real values - points - and estimated mean - bold lines - and 95 % confidence interval - thin lines - of $Y$ versus $X_1$. The dashed lines correspond to the 95 % interval due to intrinsic IV."}

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Partial_knowledge_model_genetic_var.png"))
```


```{r TwoPanelsFigure, fig.cap="Response to an environmental variable and inferred intraspecific variability. (a) Positions of a sample of $I$=600 individuals from $J$=2 species in a landscape defined by a square grid of $C x C$ cells (C=500). The background color indicates the value of the environmental variable $X_1$ (e.g., light) on each cell at date t. The response (e.g., growth) of each individual, which depends on the environment within each cell (Eq. I), is also indicated by a color scale. (b) Response as a function of the observed environmental variable $X_1$ for the two species. Points represent the data {$Y_{ijt}$, $X_{1,ijt}$}. Thick lines represent the predictive posterior means for the two species. The envelopes delimited by two thin lines represent the 95% credible intervals of the predictive posterior marginalized over individuals (taking into account $V_{bj}$). The envelopes thus represent the intraspecific variability which is due to the $N-1$ unobserved environmental variables."}

g <- ggpubr::ggarrange(A, B, ncol = 2, labels = c("a", "b"))
ggplot2::ggsave(filename = "landscape_relationship.png",plot=g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 10, height = 5, bg="white", dpi = 300)

knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "landscape_relationship.png"))

```

In Figure \@ref(fig:PlotIntrinsicIV) and panel a of Figure \@ref(fig:TwoPanelsFigure), the bold and solid (dashed) lines represent the mean rate of the response variable (e.g. growth) of Species 1 (blue) and Species 2 (orange) as computed with the parameters retrieved from the model without (with) intrinsic IV respectively. The plain lines represent the 95% interval of the posteriors from the model without intrinsic IV and the dashed lines show the 95% confidence interval of the posteriors from the model with intrinsic IV. Figure \@ref(fig:PlotIntrinsicIV) shows that intrinsic IV simply increases the overlap between the response of Species 1 and Species 2.

Figure \@ref(fig:TwoPanelsFigure) represents the virtual landscape of $X_1$ and the corresponding individual response and the plot of $Y$ versus $X_1$ (without intrinsic IV) next to each other, helping to visualise this virtual experiment.

In the model without intrinsic IV, the unobserved variation in the environment resulted in an important inferred intraspecific variability. The performances of the two species can intersect, which means that the competitive hierarchy among the two species can be locally reversed depending on the micro-environmental variation, offering opportunities for the coexistence of the two species in a variable environment. 


# Spatial autocorrelation of individual response

We then analysed the spatial structure of the response variable at the individual scale. We hypothesised that as environmental variables are spatially autocorrelated, and the response variable is the result of these variables, then the response variable should also be spatially autocorrelated.
To test this, we computed Moran’s I test. It is computed with the Moran.I function of the ape R package [@paradis_ape_2019].


```{r MoranAnalysis}

Growth_norep <- Growth[which(Growth$Time==1),] #we study the growth at time t0
Growth_1 <- Growth_norep[which(Growth_norep$Species==1),]
Growth_2 <- Growth_norep[which(Growth_norep$Species==2),]

#Growth_sp: we keep the growth without intrinsic IV
Growth_vario_all <- Growth_norep %>%
  dplyr::select(Growth_sp) %>%
  dplyr::rename(Growth = Growth_sp)%>%
  dplyr::mutate(X = as.numeric(c(Coord1_sp1, Coord1_sp2)),
                Y = as.numeric(c(Coord2_sp1, Coord2_sp2)))

Growth_vario_1 <- Growth_1 %>%
  dplyr::select(Growth_sp) %>%
  dplyr::rename(Growth = Growth_sp)%>%
  dplyr::mutate(X = as.numeric(Coord1_sp1), Y = as.numeric(Coord2_sp1))

Growth_vario_2 <- Growth_2 %>%
  dplyr::select(Growth_sp)%>%
  dplyr::rename(Growth = Growth_sp)%>%
  dplyr::mutate(X = as.numeric(Coord1_sp2), Y = as.numeric(Coord2_sp2))

#Compute distance matrices for Moran's I test 
Growth_vario_dists_all <- as.matrix(dist(cbind(Growth_vario_all$X, Growth_vario_all$Y)))
Growth_vario_dists_all_inv <- 1/Growth_vario_dists_all
diag(Growth_vario_dists_all_inv) <- 0
Mor_all <- ape::Moran.I(Growth_vario_all$Growth, Growth_vario_dists_all_inv)

Growth_vario_dists_sp1 <- as.matrix(dist(cbind(Growth_vario_1$X, Growth_vario_1$Y)))
Growth_vario_dists_sp1_inv <- 1/Growth_vario_dists_sp1
diag(Growth_vario_dists_sp1_inv) <- 0
Mor_sp1 <- ape::Moran.I(Growth_vario_1$Growth, Growth_vario_dists_sp1_inv)

Growth_vario_dists_sp2 <- as.matrix(dist(cbind(Growth_vario_2$X, Growth_vario_2$Y)))
Growth_vario_dists_sp2_inv <- 1/Growth_vario_dists_sp2
diag(Growth_vario_dists_sp2_inv) <- 0
Mor_sp2 <- ape::Moran.I(Growth_vario_2$Growth, Growth_vario_dists_sp2_inv)

Moran_I_theoretical_model <- data.frame(
  Group = c("Species 1", "Species 2", "All individuals"),
  Moran_I = c(
    format(as.numeric(Mor_sp1[1]), digits=2, scientific = T),
    format(as.numeric(Mor_sp2[1]), digits=2, scientific = T),
    format(as.numeric(Mor_all[1]), digits=2, scientific = T)
    ),
  P_value = c(
    format(as.numeric(Mor_sp1[4]), digits=2, scientific = T),
    format(as.numeric(Mor_sp2[4]), digits=2, scientific = T),
    format(as.numeric(Mor_all[4]), digits=2, scientific = T)
    )
  )
save(Moran_I_theoretical_model, file= here::here("outputs", "theoretical_model", "Moran_I_theoretical_model.RData"))
```

```{r MoranTable}
kableExtra::kbl(Moran_I_theoretical_model,
booktabs = T,
col.names = c(" ", "Moran's I index", "P-value"),
caption = "Results of the Morans's I test for both species separatly and together.") %>%
  kableExtra::kable_styling(latex_options = c("striped", "hold_position"),
                            full_width = F)
```


Table \@ref(tab:MoranTable) shows that the individual response variable is largely spatially autocorrelated. This is due to the spatial autocorrelation in the environmental variables. In this simple and controlled experiment, this seems natural. However, in a less controlled environment, detecting spatial autocorrelation in a response variable could be the sign of the spatial structure of the underlying environmental variables. Nonetheless, we acknowledge that the genetic structure of the population associated with limited dispersion for example could also lead to spatial autocorrelation in the response variable of the individuals, but this is likely to happen on a much larger geographical scale.

# Similarity between conspecific individuals compared to heterospecific individuals and consequences for species coexistence.

Finally, we used semivariograms to visualise the spatial autocorrelation of the response variable and to test whether the individual response was more similar within conspecifics than within heterospecifics.
The semivariograms were computed and modelled with the variogram and the fit.variogram functions of the gstat R package ([@pebesma_multivariable_2004, @graler_spatio-temporal_2016]) respectively. The variogram models were spherical.


```{r Semivariograms}
#Prepare data for variogram computation
sp::coordinates(Growth_vario_all) = ~X+Y
sp::coordinates(Growth_vario_1) = ~X+Y
sp::coordinates(Growth_vario_2) = ~X+Y

Vario_all <- gstat::variogram(Growth~X+Y, data=Growth_vario_all, width=0.5, cutoff=500)
Vario_1 <- gstat::variogram(Growth~X+Y, data=Growth_vario_1, width=0.5, cutoff=500)
Vario_2 <- gstat::variogram(Growth~X+Y, data=Growth_vario_2, width=0.5, cutoff=500)

#Fit spherical variogram models
Vario_all.fit = gstat::fit.variogram(Vario_all, gstat::vgm("Sph"))
Vario1.fit = gstat::fit.variogram(Vario_1, gstat::vgm("Sph"))
Vario2.fit = gstat::fit.variogram(Vario_2, gstat::vgm("Sph"))

vgLine <- rbind(
  cbind(gstat::variogramLine(Vario_all.fit, maxdist = max(Vario_all$dist)), id = "All"),
  cbind(gstat::variogramLine(Vario1.fit, maxdist = max(Vario_1$dist)), id = "Species 1"),
  cbind(gstat::variogramLine(Vario2.fit, maxdist = max(Vario_2$dist)),id="Species 2")
)

```

```{r SemivariogramFigure, warning=FALSE, fig.cap="Spatial autocorrelation of response Y across individuals within and between species (J=2).This semivariogram represents the semivariance of the individual mean responses Y as a function of the distance between individuals. The increasing curves evidence spatial autocorrelation in Y (similar results using Moran’s I test). The semivariance of all individuals taken together (purple curve) is higher than the semivariance of conspecifics for the two species (red and blue curves), which means that intraspecific variability is lower than interspecific variability."}
#Plot variogram models
g <- ggplot2::ggplot(rbind(Vario_all, Vario_1, Vario_2), ggplot2::aes(x = dist, y = gamma, colour = id)) +
  ggplot2::geom_point(data=Vario_all, ggplot2::aes(colour="All"), alpha=0.5) +
  ggplot2::geom_point(data=Vario_1, ggplot2::aes(dist, gamma, colour="Species 1"), alpha=0.5) +
  ggplot2::geom_point(data=Vario_2, ggplot2::aes(dist, gamma, colour="Species 2"), alpha=0.5) +
  ggplot2::geom_line(data = vgLine) +
  ggplot2::scale_color_manual(name="Individuals\nstudied", values=c("violetred", "midnightblue", "orange")) +
  ggplot2::xlab("Distance") +
  ggplot2::ylab("Semivariance") +
  ggplot2::xlim(0,100) +
  ggplot2::theme(
    legend.title = ggplot2::element_text(size = 12),
    legend.text = ggplot2::element_text(size = 10),
    text = ggplot2::element_text(size=12))

ggplot2::ggsave(filename = "Semivariograms.png", plot = g, path=here::here("outputs", "theoretical_model", "figures"), device = "png", width = 7, height = 5, dpi = 300)
knitr::include_graphics(here::here("outputs", "theoretical_model", "figures", "Semivariograms.png"))
```


As the semivariance between individuals of both species was higher than the semivariance between conspecifics (Figure \@ref(fig:SemivariogramFigure)), the individual response variable was more similar between conspecifics than heterospecifics. Considering this response variable as a proxy of the species performance, we argue that this would imply that intraspecific competition is greater than interspecific competition), which is the main condition for stable coexistence.
Therefore, **stable** coexistence is possible even with high intraspecific variability, especially when this variability is not intrinsic but due to environmental heterogeneity that is structured in space.


# Code implementation

The whole analysis is done using the R language [@R] in the Rstudio environment [@RStudio]. The tables are made with the kableExtra package [@kableExtra], the figures with the package ggplot2 [@wickham_ggplot2_2009], and the code uses  other packages of the Tidyverse [@wickham_welcome_2019] (dplyr [@dplyr], magrittr [@magrittr]) and other R packages (here [@here], ggpubr [@ggpubr], sp [@sp; @bivand_applied_2013], ggnewscale [@ggnewscale], gstat [@pebesma_multivariable_2004, @graler_spatio-temporal_2016]). The pdf and html documents are produced thanks to the R packages rmarkdown [@Allaire2020-sr; @xie_r_2019; @xie_r_2020], knitr [@knitr; @xie_dynamic_2015; @stodden_knitr_2014] and bookdown [@xie_bookdown_2017].

# References
